## OSI层次模型
![OSI](https://github.com/Elderkly/ImgRepository/blob/master/Network/结构.png)

## 概念
* 面向连接：发送数据之前先建立好会话连接
* 面向无连接：无需建立会话连接即可传输数据
* 可靠传输：不错、不乱、不丢
  
## UDP与TCP
||UDP|TCP|
|:-:|:-:|:-:|
|面向|报文|字节|
|可靠性|不可靠|可靠|
|首部长度|8B|20B|
|传输方式|单播，多播，广播|单播|

## Get和Post的区别
副作用：对服务器资源做变动    
例：搜索是无副作用，用户注册是副作用的   
幂等：指对服务器进行不同次数操作，服务器的资源状态一致   
例：搜索是幂等的，注册是不幂等的   
**Get：多用于无副作用、幂等的场景**   
**Post：多用与副作用、不幂等的场景**

在技术上说：
* Get 请求能缓存，Post 不能
* Post 相对 Get 安全一点点，因为Get 请求都包含在 URL 里，且会被浏览器保存历史纪录，Post 不会，但是在抓包的情况下都是一样的。
* Post 可以通过 request body来传输比 Get 更多的数据，Get 没有这个技术
* URL有长度限制，会影响 Get 请求，但是这个长度限制是浏览器规定的，不是 RFC 规定的
* Post 支持更多的编码类型且不对数据类型限制


## Get缓存
#### 1.Http缓存   
当客户端向服务器请求资源时，会先抵达浏览器缓存，如果浏览器有“要请求资源”的副本，就可以直接从浏览器缓存中提取而不是从原始服务器中提取这个资源。   
常见的http缓存只能缓存get请求响应的资源，对于其他类型的响应无能为力。
#### 2.Get缓存如何生效
后端设置response header，expires字段设置缓存有效时间，cache-control字段可以指定是否使用缓存，或是缓存过期时间
#### 3.禁用缓存
浏览器NetWork窗口勾选Disabled cache，或是在Get请求后携带时间戳，让每一次Get请求携带的数据都不一样。

## 状态码
|状态码|含义|   
|:-:|:-|
|200|OK|
|204|No content|
|205|Reset Content 要求请求方重置内容|
|206|进行范围请求|
|301|永久性重定向，表示资源已被分配了新的 URL|
|302|临时性重定向，表示资源临时被分配了新的 URL|
|303|表示资源存在着另一个 URL，应使用 GET 方法获取资源|
|304|表示服务器允许访问资源，但因发生请求未满足条件的情况（可能是浏览器缓存过期或是资源有更新）|
|307|临时性重定向，期望客户端保持原有方式向新地址发出请求|
|400|请求报文存在语法错误|
|401|缺少HTTP认证信息|
|403|被服务器拒绝访问|
|404|没找到请求的资源|
|500|服务端错误|
|501|服务器不支持该功能|
|503|服务器繁忙，无法处理请求|


## HTTPS
### TLS
TLS 协议位于传输层之上，应用层之下。首次进行 TLS 协议传输需要两个 RTT ，接下来可以通过 Session Resumption 减少到一个 RTT。   
在 TLS 中使用了两种加密技术，分别为：**对称加密和非对称加密**。
* 对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密。
* 非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道。
  
#### TLS握手过程
> 在握手过程中采用**非对称加密**的方式，而在正式传输过程采用**对称加密**的方式。   
> TLS握手的过程共需生成**三个随机数**，其中客户端生成两个，服务端生成一个。   

1.客户端**发送一个随机值**，需要的协议和加密方式   
2.服务端收到客户端的随机值，自己也**产生一个随机值**，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）   
3.客户端收到服务端的证书并验证是否有效，验证通过会**再生成一个随机值**，通过服务端证书的**公钥去加密**这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书   
4.服务端收到加密过的随机值并使用**私钥解密**获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成**密钥**，接下来的通信就可以通过该密钥来加密解密。   
     
**PS：以上说明的都是 TLS 1.2 协议的握手情况，在 1.3 协议中，首次建立连接只需要一个 RTT，后面恢复连接不需要 RTT 了。**   
   
![TLS握手过程](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043749.jpg)

## HTTP2.0
### 1.X弊端
在1.X中，因为浏览器限制了同一个域名下的请求数量，当页面中需要请求很多资源的时候，队头阻塞会导致在达到最大请求数量时，剩余的资源需要等待其他资源请求完成后才能发起请求。

### 二进制传输
在1.X中采用文本进行数据传输，而在2.0中采用二进制进行传输

### 多路复用
* 帧：最小的数据单位
* 流：帧属于流，多个帧组成流   
  
多路复用，就是在一个 TCP 连接中可以存在多条流。对端可通过帧中的标识得知是哪个请求。

### Header 压缩
在 HTTP 1.X 中，我们使用文本的形式传输 header，在 header 携带 cookie 的情况下，可能每次都需要重复传输几百到几千的字节。   
在 HTTP 2.0 中，使用了 HPACK 压缩格式对传输的 header 进行编码，减少了 header 的大小。并在两端维护了索引表，用于记录出现过的 header ，后面在传输过程中就可以传输已经记录过的 header 的键名，对端收到数据后就可以通过键名找到对应的值。

## DNS
DNS 的作用就是通过域名查询到具体的 IP。   
![DNS](https://github.com/Elderkly/ImgRepository/blob/master/Network/域名系统(DNS).png)

## 从输入 URL 到页面加载完成的过程
![process](https://github.com/Elderkly/ImgRepository/blob/master/Network/%E7%94%A8%E6%88%B7%E9%80%9A%E8%BF%87%E4%B8%BB%E6%9C%BA%E8%AE%BF%E9%97%AE%E5%9F%9F%E5%90%8D%E6%97%B6%E7%9A%84%E8%BF%87%E7%A8%8B.png)

## 针对中国大陆无法访问 vercel.com 资源

vercel.com 的 DNS 被污染，配置一个中国大陆可以访问的域名可解决。

**https://github.com/orgs/vercel/discussions/803**  
**https://vercel.com/docs/concepts/projects/domains**

#### 配置域名

只能在 dns 服务器上进行配置:

- 验证你对该域名的控制权 配置 TEXT 记录（TXT Record：
  TEXT 记录是一种 DNS 记录类型，用于存储与域名相关的文本信息。在 Vercel 的情况下，你需要在 DNS 设置中创建一个 TEXT 记录，并将其值设置为 Vercel 提供的特定文本字符串。这个 TEXT 记录的作用是验证你对该域名的控制权，确保你有权将该域名与 Vercel 的服务进行关联。
- 建立域名的别名关系 配置 CNAME 记录（Canonical Name Record）：
  CNAME 记录也是一种 DNS 记录类型，用于建立域名的别名关系。在 Vercel 上配置 CNAME 记录的目的是将你的自定义域名指向 Vercel 的服务。你需要在 DNS 设置中创建一个 CNAME 记录，并将别名（自定义域名）指向 Vercel 提供的目标地址（通常是一个 Vercel 提供的域名）。

#### 原因

当你直接访问 abc.vercel.com 时，请求会直接发送到 Vercel 的服务器，但由于该域名的 DNS 被污染，DNS 解析可能会失败或导致资源加载超时或连接被拒绝的问题。这是因为 DNS 被污染后，无法正确解析到 Vercel 服务器的 IP 地址。

然而，当你通过配置了域名 abc.baidu.com 并访问它时，请求会首先发送到 Baidu 的 DNS 服务器。由于 Baidu 的 DNS 服务器并未受到污染，它能够正常解析到你配置的 CNAME 记录 cname.vercel-dns.com.，然后将请求转发到 Vercel 的 DNS 服务器。

Vercel 的 DNS 服务器收到请求后，会解析到正确的目标地址（例如 abc.vercel.com），然后将请求转发到 Vercel 的服务器。因为这个转发过程是在 DNS 服务器层级上进行的，所以即使 vercel.com 的 DNS 被污染，你仍然能够通过 abc.baidu.com 访问到 Vercel 的资源，因为请求的 DNS 解析是在 Baidu 的 DNS 服务器上进行的。

这种方式实际上是通过配置一个中间域名（abc.baidu.com），将请求从一个正常运行的 DNS 服务器转发到另一个受污染的域名的 DNS 服务器，然后再将请求路由到正确的目标地址。这样可以绕过污染的 DNS 解析，确保请求能够正确到达 Vercel 的服务器。

需要注意的是，这种方式只是一种临时解决方案，目的是为了绕过 DNS 污染问题。如果 vercel.com 的 DNS 污染问题得到解决，直接访问 abc.vercel.com 也应该能够正常工作。

#### 请求过程

1. 用户在浏览器中输入 abc.baidu.com。
2. 操作系统的网络设置向配置的 DNS 服务器发送 DNS 查询请求，以获取 abc.baidu.com 的 IP 地址。
3. DNS 服务器接收到查询请求后，在自己的记录中查找 abc.baidu.com 的 DNS 记录。
4. 如果找到了 abc.baidu.com 的 CNAME 记录，并且目标地址是 cname.vercel-dns.com.，则 DNS 服务器会将请求转发到 Vercel 的 DNS 服务器。
5. Vercel 的 DNS 服务器接收到请求后，根据其记录将请求转发到正确的目标地址（例如 abc.vercel.com）。
6. 用户的操作系统接收到目标地址后，通过网络路由将请求发送到对应的服务器，这里是 Vercel 的服务器。
7. Vercel 的服务器接收到请求，并返回与该请求对应的内容。
8. 用户的浏览器接收到服务器返回的内容，并将其显示给用户。

#### SNI 和 DNS 污染

SNI（Server Name Indication）和 DNS（Domain Name System）污染是与网络通信和域名解析相关的两个概念。

- SNI（Server Name Indication）：SNI 是一种扩展协议，用于在进行 TLS（Transport Layer Security）握手时，向服务器指示客户端要访问的域名。在使用 SNI 之前，TLS 握手只能根据 IP 地址来确定要访问的服务器，而无法区分多个共享同一 IP 地址的域名。通过 SNI，客户端可以在握手过程中发送目标域名信息，服务器则可以根据域名来选择合适的证书和配置。

- DNS 污染：DNS 污染是指在 DNS 查询过程中，恶意修改或篡改 DNS 响应的行为。这可能导致域名解析出现错误的结果或无法解析到正确的 IP 地址。DNS 污染可能是由于恶意攻击、网络干扰、劫持或错误的 DNS 配置引起的。当 DNS 污染发生时，用户可能无法访问正确的网站，或者被重定向到恶意网站。

这两个概念在以下情况下可能会有关联：

当 DNS 污染发生时，域名解析的结果可能被修改，导致客户端无法正确解析到目标服务器的 IP 地址。这可能会导致 SNI 握手过程中出现问题，因为客户端无法正确识别服务器所使用的域名。这可能导致 TLS 握手失败、证书验证错误或无法建立安全连接。

因此，DNS 污染可能会对 SNI 握手过程和安全连接产生影响。在这种情况下，使用已被污染的 DNS 服务器进行域名解析可能会导致与服务器的通信问题。

为了解决这些问题，你可以尝试使用可靠的、未被污染的 DNS 服务器进行域名解析，或者使用 VPN（Virtual Private Network）等工具来保护网络通信的安全性和可靠性。


### 服务端渲染的过程
1.用户输入网址：用户在浏览器地址栏输入网址并按下回车键。   

2.DNS 解析：浏览器首先会进行 DNS 解析，将网址转换为服务器的 IP 地址。   

3.建立连接：浏览器根据解析得到的 IP 地址与服务器建立 TCP 连接。   

4.发送请求：浏览器向服务器发送 HTTP 请求，请求用户想要访问的页面。   

5.服务器处理请求：服务器接收到请求后，如果是 Next.js 应用，它会根据请求的路由找到对应的页面组件。   

6.服务端渲染：在服务器端渲染中，Next.js 提供了 getServerSideProps 或 getInitialProps 这样的特殊方法，用于在渲染页面之前获取数据。通过这些方法，您可以从数据库、API 或其他数据源获取数据，并将其传递给页面组件。   

7.生成 HTML：React 组件在服务器上被渲染成 HTML 字符串。这个过程通常使用 react-dom/server 的 renderToString 方法。   

8.发送响应：服务器将渲染好的 HTML 字符串，以及可能的初始状态数据（通过 context 对象传递），作为 HTTP 响应发送回浏览器。   

9.浏览器接收响应：浏览器接收到服务器的响应后，开始解析 HTML，构建 DOM 树。   

10.客户端渲染：浏览器会解析 HTML 内容，并构建页面的 DOM 树。同时，浏览器会加载页面中所需的 JavaScript、CSS 和其他资源。    

11.页面加载完成：客户端完成所有必要的资源加载和脚本执行后，页面变得可交互，用户可以看到完整的页面内容。

## 缓存

### 浏览器缓存

**Web 缓存种类：** 数据库缓存，CDN 缓存，代理服务器缓存，浏览器缓存。  
**浏览器缓存过程：** 强缓存，协商缓存。  
**浏览器缓存位置一般分为四类：** Service Worker-->Memory Cache-->Disk Cache-->Push Cache。

#### 浏览器缓存相关字段

![字段](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0c82d0049c3f4f57bf66d8effcb25ed5~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

#### 缓存分类

![缓存分类](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/70f599db34fa42068ccfa4e04748a078~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)
|      名称      |                                       用途                                        |
| :------------: | :-------------------------------------------------------------------------------: |
| Service Worker |       是运行在浏览器背后的独立线程，一般可以用来实现缓存功能，只支持 HTTPS        |
|  Memory Cache  |  存放于内存中的缓存，大多用于存放样式、脚本文件，存放时间短，随着进程释放而释放   |
|   Disk Cache   |       存放于硬盘中的缓存，大多用于存放图片、视频资源等，存放时间长，容量大        |
| prefetch cache | prefetch 是预加载的一种方式，被标记为 prefetch 的资源，将会被浏览器在空闲时间加载 |
|   Push Cache   |    HTTP2 的内容，在其他缓存没命中的情况下使用，存放时间短，随着进程释放而释放     |

#### 缓存过程

##### 强缓存

首次请求：如果响应头中`expires`、`pragma`或者`cache-control`字段，代表这是强缓存，浏览器就会把资源缓存在 memory cache 或 disk cache 中。  
第二次请求：如果符合强缓存条件就直接返回状态码 200，从本地缓存中拿数据。否则把响应参数存在 request header 请求头中，看是否符合协商缓存，符合则返回状态码 304，不符合则服务器会返回全新资源。  
![强缓存](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ca00bff3081e4cfd993a8f252f4fa23a~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

##### 协商缓存

协商缓存就是强缓存失效后，浏览器携带缓存标识向服务器发送请求，由服务器根据缓存标识来决定是否使用缓存的过程。  
服务器资源未更新：返回 304，读取缓存  
服务器资源更新：重新请求，返回 200  
**实现协商缓存:**

- Last-Modified / If-Modified-Since：服务端返回 Last-Modified 即文件最后修改时间，客户端请求时将其写入请求头的 If-Modified-Since 字段，服务端对比文件修改时间，若服务端文件修改时间大于 If-Modified-Since 则重新返回资源和 200 状态码，否则返回 304，代表资源无更新，可继续使用缓存文件。
- Etag / If-None-Match：服务端返回 Etag 字段即服务器生成的文件唯一标识，客户端将其写入 If-None-Match 字段中，服务端收到后判断客户端的 If-None-Match 与服务端文件的唯一标识是否一致，一致则返回 304，否则返回 200.

**Etag / If-None-Match 优先级高于 Last-Modified / If-Modified-Since，同时存在则只有 Etag / If-None-Match 生效。**

#### 强缓存与协商缓存的区别

1. 强缓存不发请求到服务器，所以有时候资源更新了浏览器还不知道，但是协商缓存会发请求到服务器，所以资源是否更新，服务器肯定知道。
2. 大部分 web 服务器都默认开启协商缓存。

#### 刷新对于强缓存和协商缓存的影响

1. 当 ctrl+f5 强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存。
2. 当 f5 刷新网页时，跳过强缓存，但是会检查协商缓存。
3. 浏览器地址栏中写入 URL，回车 浏览器发现缓存中有这个文件了，不用继续请求了，直接去缓存拿。（最快）

https://juejin.cn/post/6947936223126093861

### vercel相关
#### 缓存

##### 针对静态资源配置缓存需要在根目录创建 vercel.json 文件

```json
{
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        {
          "key": "Cache-Control",
          "value": "public, max-age=600, immutable"
        }
      ]
    }
  ]
}
```

##### 针对 SSR 做缓存

```typescript
export async function getServerSideProps(context: GetServerSidePropsContext) {
  const {
    res,
    query: { t, id },
  } = context;
  res.setHeader(
    'Cache-Control',
    'public, s-maxage=30, stale-while-revalidate=300'
  );
  ...
  return {
    props: {
      ...
    }
  };
}
```

相关字段说明：

- public：表示响应可以被公共缓存（例如 CDN）缓存。
- s-maxage=10：表示在 10 秒内，响应被视为新鲜（fresh）。在这个时间范围内，重复的请求将使用之前缓存的值而不是向后端服务器发起新的请求。
- stale-while-revalidate=59：表示在 59 秒内，即使缓存的值已过期（stale），仍然可以使用该值进行渲染，同时后台会发起重新验证的请求来更新缓存的值。
- immutable: 指令表示资源在指定时间段内是不可变的，因此浏览器和 CDN 可以安全地缓存资源并在缓存过期之前不再验证。
- must-revalidate: 指令要求浏览器在每次使用缓存资源之前都向服务器发送验证请求，以确保资源是否仍然有效。