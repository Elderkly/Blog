#### 排序 Gif

https://www.cnblogs.com/onepixel/articles/7674659.html

## 按位操作

| 操作符 |          含义          |  示例   |
| :----: | :--------------------: | :-----: |
|   <<   |     算数左移 补 0      | 8<<1=16 |
|   >>   |     算数右移 舍去      | 8>>1=4  |
|   &    |  按位与 全为 1 才为 1  |  8&7=0  |
|   \|   | 按位或 有一个 1 即为 1 | 8\|7=15 |
|   ^    |   按位异或 同 0 异 1   | 8^7=15  |

## 排序算法对比

![排序](https://github.com/Elderkly/ImgRepository/blob/master/DataStructure/排序对比.png)

### 区分插入排序和选择排序

插入排序：第一个元素默认是已排序元素，取出下一个元素和当前元素比较，如果当前元素大就交换位置。

选择排序：遍历数组，设置最小值的索引为 0，如果取出的值比当前最小值小，就替换最小值索引，遍历完成后，将第一个元素和最小值索引上的值交换。

### 快速排序

1.设置两个指针放在队头和队尾分别为 low 指针和 high 指针  
2.将第一个元素作为枢轴元素  
3.将队尾的 high 指针向左移动，查找第一个小于枢轴的元素，将其放到 low 指针所指的位置  
4.将 low 指针向右移动，查找第一个大于枢轴的元素，将其放到 high 指针位置  
5.循环 3、4 过程直到 low 指针和 high 指针碰撞  
6.将枢轴元素放到 low 指针和 high 指针碰撞的位置  
7.对枢轴元素两侧的子表用同样的方法进行递归排序

### 堆排序

1.对建立好的堆取头结点跟最后一个叶结点互换位置  
2.按照大/小根堆交换位置  
3.递归

## 动态规划

动态规划背后的基本思想非常简单。就是将一个问题拆分为子问题，一般来说这些子问题都是非常相似的，那么我们可以通过只解决一次每个子问题来达到减少计算量的目的。

一旦得出每个子问题的解，就存储该结果以便下次使用。
